- More data types (float, string, etc. )
    - use Quarter instead of Short
    - consider how to specify types in source code
        - float, h_float, uh_float, u_int, uq_int
        - float, half float, unsigned half float, unsigned int, unsigned quarter int
- Refine error printing for the compiler
- Rework binary files, to this:
    - VM use Macros for simple types again
    - If a command_line argument could not be parsed, check if it a legal global variable
- Cleanup the codebase
- Do some automated testing
- Generalize PLACE_* instructions by size
- Implement generic type resolution
    - Some thing like: "if (T is int) { ... } "
    - Would strengthen type composition
- Implement HOR (Higher-order-routines)
    - Some thing like: "internal map<T,U>(target: T[], rt: _(T,U))"
    - Where "_(T,U)" is some routine taking arguments (T,U)
    - Would strengthen generics, but might be weird to work with.
- Add location data to global variable declarations, struct declarations and routines declarations.
- Implement struct literals
  - syntax examples:
    - t1 :tuple<int,int>:= {1,2};
    - t1 :tuple:= {1,2};
    - l1 :list<int>:= {1, {2, {3, null}}};
    - l1 :list:= {1, {2, {3, null}}};
  - will not be supported for infered declarations, as a struct type is required to check against
  - a struct literal matches a struct type, if each expression in it matches it index-wise corresponding struct field, both with regards to lock state and type.
  - requires quite a few special case, throughout the code base.